# 一、数据库设计

`create database hotel_system`

## 1.核心实体表设计
*这些 SQL 语句包含了文档中要求的 18位身份证校验、性别默认值、价格非负约束等功能 。*

### (1)用户表 (包含VIP等级与积分)
```
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    real_name VARCHAR(50) NOT NULL,
    phone VARCHAR(20),
    points INT DEFAULT 0, -- 用户积分 
    is_vip BOOLEAN DEFAULT FALSE, -- 积分多可升级VIP 
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### (2)酒店表
```
CREATE TABLE hotels (
    hotel_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    city VARCHAR(50) NOT NULL, -- 城市名查询 
    district VARCHAR(50) NOT NULL, -- 区域名查询 
    address TEXT,
    description TEXT
);
```

### (3)客房表
```
CREATE TABLE rooms (
    room_id SERIAL PRIMARY KEY,
    hotel_id INT REFERENCES hotels(hotel_id),
    room_type VARCHAR(50) NOT NULL, -- 非空约束 
    price DECIMAL(10, 2) NOT NULL DEFAULT 0.0, -- 货币类型缺省值 
    capacity INT DEFAULT 2, -- 一间房可入住多人 
    total_inventory INT NOT NULL, -- 总房间数
    available_inventory INT NOT NULL, -- 当前剩余可预订数
    CHECK (price >= 0)
);
```

### (4)订单表
```
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(user_id),
    hotel_id INT REFERENCES hotels(hotel_id),
    room_type VARCHAR(50),
    total_price DECIMAL(10, 2) DEFAULT 0.0,
    status VARCHAR(20) DEFAULT 'booked', -- booked, stayed, cancelled 
    check_in_date DATE NOT NULL DEFAULT CURRENT_DATE, -- 缺省日期 
    check_out_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT check_dates CHECK (check_out_date > check_in_date) -- 离店不小于入住时间 
);
```

### (5)入住人明细表 (支持一次预定多间，多人入住)
```
CREATE TABLE order_guests (
    guest_id SERIAL PRIMARY KEY,
    order_id INT REFERENCES orders(order_id) ON DELETE CASCADE,
    name VARCHAR(50) NOT NULL,
    gender CHAR(1) DEFAULT 'M', -- 性别缺省 
    id_card CHAR(18) NOT NULL, -- 规则：必须18位 
    age INT,
    occupation VARCHAR(50), -- 职业，用于统计 
    income_level VARCHAR(20), -- 收入状况 
    education VARCHAR(50), -- 教育程度 
    CONSTRAINT check_id_len CHECK (length(id_card) = 18) -- 实施规则 
);
```

## 2.视图与触发器
### (1)酒店客房信息视图
*满足“查看某城市某区域酒店时，显示所有客房详细信息”的要求 。*
```
CREATE VIEW view_hotel_rooms AS
SELECT 
    h.city, h.district, h.name AS hotel_name, 
    r.room_type, r.price, r.available_inventory, r.capacity
FROM hotels h
JOIN rooms r ON h.hotel_id = r.hotel_id;
```

### (2)预订自动扣减库存触发器
*当订单状态变为 'booked' 时，自动减少 rooms 表中的可用数量 。*
```
CREATE OR REPLACE FUNCTION update_room_inventory()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE rooms SET available_inventory = available_inventory - 1
        WHERE hotel_id = NEW.hotel_id AND room_type = NEW.room_type;
    ELSIF (NEW.status = 'cancelled' AND OLD.status != 'cancelled') THEN
        UPDATE rooms SET available_inventory = available_inventory + 1
        WHERE hotel_id = NEW.hotel_id AND room_type = NEW.room_type;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_booking
AFTER INSERT OR UPDATE ON orders
FOR EACH ROW EXECUTE FUNCTION update_room_inventory();
```

## 3.索引优化 (提高查询性能)
- 城市与区域索引: CREATE INDEX idx_hotel_location ON hotels(city, district); (针对频繁的地域搜索)
- 订单日期索引: CREATE INDEX idx_order_date ON orders(check_in_date); (针对汇总统计)

# 二、构建Go后端
我们将使用 Gin（高性能 Web 框架）和 GORM（对象关系映射工具）。GORM 能让我们像操作对象一样操作数据库，非常适合处理文档中要求的复杂逻辑。

## 1.初始化项目
*在backend目录下执行：*
```
go mod init hotel-system
go get -u github.com/gin-gonic/gin
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
```

## 2.目录结构
```
/backend
  ├── main.go          # 程序入口
  ├── config/          # 数据库连接配置
  ├── models/          # 数据库模型 (与表对应) 
  ├── controllers/     # 业务逻辑处理 (API 接口)
  └── routes/          # 路由定义
```

## 3.连接PostgreSQL(config/db.go)
```
package config

import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "log"
)

var DB *gorm.DB

func ConnectDatabase() {
    dsn := "host=localhost user=postgres password=你的密码 dbname=hotel_db port=5432 sslmode=disable"
    database, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})

    if err != nil {
        log.Fatal("Failed to connect to database!", err)
    }

    DB = database
    DB.AutoMigrate(&models.User{}, &models.Hotel{}, &models.Room{}, &models.Order{}, &models.OrderGuest{})
}
```

## 4.定义模型(models/user.go)
我们需要在 Go 中定义与数据库对应的结构。根据文档要求，用户信息需要维护，且包含积分和 VIP 逻辑 。
```
package models

import "time"

type User struct {
    UserID       uint      `gorm:"primaryKey;autoIncrement" json:"user_id"`
    Username     string    `gorm:"unique;not null" json:"username"`
    PasswordHash string    `gorm:"not null" json:"-"` // 密码不返回给前端
    RealName     string    `json:"real_name"`
    Points       int       `gorm:"default:0" json:"points"`
    IsVip        bool      `gorm:"default:false" json:"is_vip"`
    CreatedAt    time.Time `json:"created_at"`
}
```

## 5.编写用户注册逻辑(controllers/user.go)
*必须注册用户，合法用户才可以预定酒店 。*
```
package controllers

import (
    "hotel-system/config"
    "hotel-system/models"
    "net/http"
    "github.com/gin-gonic/gin"
)

func Register(c *gin.Context) {
    var input struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
        RealName string `json:"real_name" binding:"required"`
    }

    // 1. 验证输入格式 
    if err := c.ShouldBindJSON(&input); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "输入数据不合法"})
        return
    }

    // 2. 创建用户对象
    user := models.User{
        Username:     input.Username,
        PasswordHash: input.Password, // 实际开发建议用 bcrypt 加密
        RealName:     input.RealName,
    }

    // 3. 写入数据库
    if err := config.DB.Create(&user).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "注册失败，用户名可能已存在"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "注册成功", "data": user})
}

// Login 用户登录逻辑
func Login(c *gin.Context) {
    var input struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
    }

    if err := c.ShouldBindJSON(&input); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "请输入用户名和密码"})
        return
    }

    var user models.User
    // 1. 根据用户名查询用户
    if err := config.DB.Where("username = ?", input.Username).First(&user).Error; err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户名或密码错误"})
        return
    }

    // 2. 校验密码 (注意：实际开发中应使用 bcrypt.CompareHashAndPassword)
    if user.PasswordHash != input.Password {
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户名或密码错误"})
        return
    }

    // 3. 返回用户信息 (实际项目中这里会生成并返回 JWT Token)
    c.JSON(http.StatusOK, gin.H{
        "message": "登录成功",
        "user_id": user.UserID,
        "is_vip":  user.IsVip,
        "username": user.Username,
    })
}
```

## 6.酒店与房型搜索
*根据要求，用户需要根据城市、区域、价格范围和日期来查询酒店清单 。*

**控制器实现 (controllers/hotel.go)**

这里我们要实现多条件组合查询，并返回酒店及其对应的房型信息。
```
func SearchHotels(c *gin.Context) {
    city := c.Query("city")
    district := c.Query("district")
    minPrice := c.DefaultQuery("min_price", "0")
    maxPrice := c.DefaultQuery("max_price", "999999")

    var results []struct {
        models.Hotel
        Rooms []models.Room `gorm:"foreignKey:HotelID"`
    }

    // 构造查询：关联查询酒店及其符合价格条件的房型
    query := config.DB.Preload("Rooms", "price BETWEEN ? AND ?", minPrice, maxPrice).Model(&models.Hotel{})

    if city != "" {
        query = query.Where("city = ?", city)
    }
    if district != "" {
        query = query.Where("district = ?", district)
    }

    if err := query.Find(&results).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "查询失败"})
        return
    }
    c.JSON(http.StatusOK, results)
}
```

## 7.核心预订逻辑(事务与并发控制)
*处理并发控制，防止多个客户同时抢订最后一间房 。*

**预订处理 (controllers/order.go)**

我们采用 数据库事务 + 行级锁 (Select for Update) 来确保数据的绝对安全。
```
func CreateOrder(c *gin.Context) {
    var req struct {
        UserID    uint      `json:"user_id"`
        HotelID   uint      `json:"hotel_id"`
        RoomType  string    `json:"room_type"`
        CheckIn   time.Time `json:"check_in"`
        CheckOut  time.Time `json:"check_out"`
        Guests    []models.OrderGuest `json:"guests"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "参数错误"})
        return
    }

    // 开启事务
    err := config.DB.Transaction(func(tx *gorm.DB) error {
        // 1. 锁定并检查库存 (FOR UPDATE 保证并发安全)
        var room models.Room
        if err := tx.Set("gorm:query_option", "FOR UPDATE").
            Where("hotel_id = ? AND room_type = ?", req.HotelID, req.RoomType).
            First(&room).Error; err != nil {
            return err // 房间不存在
        }

        if room.AvailableInventory <= 0 {
            return errors.New("客房已售罄")
        }

        // 2. 计算优惠价格 (VIP 策略 )
        var user models.User
        tx.First(&user, req.UserID)
        finalPrice := room.Price
        if user.IsVip {
            finalPrice = room.Price * 0.8 // VIP 8折优惠 
        }

        // 3. 创建订单
        newOrder := models.Order{
            UserID: req.UserID,
            HotelID: req.HotelID,
            RoomType: req.RoomType,
            TotalPrice: finalPrice,
            CheckInDate: req.CheckIn,
            CheckOutDate: req.CheckOut,
            Status: "booked",
        }
        if err := tx.Create(&newOrder).Error; err != nil {
            return err
        }

        // 4. 保存入住人信息 
        for i := range req.Guests {
            req.Guests[i].OrderID = newOrder.OrderID
            if err := tx.Create(&req.Guests[i]).Error; err != nil {
                return err
            }
        }

        // 注意：房间库存的减少由我们在数据库设计的触发器自动完成 
        return nil
    })

    if err != nil {
        c.JSON(http.StatusConflict, gin.H{"error": err.Error()})
        return
    }
    c.JSON(http.StatusOK, gin.H{"message": "预订成功"})
}

// CancelOrder 处理退订请求
func CancelOrder(c *gin.Context) {
    orderID := c.Param("id") // 从 URL 路径获取订单 ID
    userID := c.Query("user_id") // 实际应从 JWT 中获取，此处简化处理

    var order models.Order
    // 1. 查找订单并校验所属权
    if err := config.DB.Where("order_id = ? AND user_id = ?", orderID, userID).First(&order).Error; err != nil {
        c.JSON(http.StatusNotFound, gin.H{"error": "订单不存在或无权操作"})
        return
    }

    // 2. 校验状态：只有已预订但未入住的订单可以退订 
    if order.Status != "booked" {
        c.JSON(http.StatusBadRequest, gin.H{"error": "当前订单状态不支持退订"})
        return
    }

    // 3. 更新状态为 cancelled
    // 这里的更新会触发数据库中的 update_room_inventory 触发器，自动增加可用库存
    if err := config.DB.Model(&order).Update("status", "cancelled").Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "退订失败"})
        return
    }

    c.JSON(http.StatusOK, gin.H{"message": "退订成功，房间已释放"})
}
```

## 8.汇总统计功能(存储过程调用)
*按城市、区域等因素统计预订情况 。在 Go 中，我们可以直接调用之前在数据库中定义的存储过程。(controllers/statistics.go)*
```
package controllers

import (
    "hotel-system/config"
    "net/http"
    "github.com/gin-gonic/gin"
)

// GetBookingStats 对应文档要求 7.1：按城市、区域、酒店等统计预定情况
func GetBookingStats(c *gin.Context) {
    var results []map[string]interface{}
    
    // 执行原生 SQL 或调用存储过程
    // 如果你在数据库里写了存储过程，可以用 config.DB.Raw("CALL your_procedure_name()")
    query := `
        SELECT h.city, h.district, h.name as hotel_name, COUNT(o.order_id) as total_bookings
        FROM hotels h
        LEFT JOIN orders o ON h.hotel_id = o.hotel_id
        GROUP BY h.city, h.district, h.name
    `
    
    if err := config.DB.Raw(query).Scan(&results).Error; err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "统计查询失败"})
        return
    }

    c.JSON(http.StatusOK, results)
}

// GetGuestAnalysis 对应文档要求 7.2：按入住人画像（年龄、职业等）统计
func GetGuestAnalysis(c *gin.Context) {
    var analysis []map[string]interface{}
    
    query := `
        SELECT occupation, education, COUNT(*) as count
        FROM order_guests
        GROUP BY occupation, education
    `
    
    config.DB.Raw(query).Scan(&analysis)
    c.JSON(http.StatusOK, analysis)
}
```

## 9.酒店与客房模型(models/hotel.go)
*这里包含了酒店的基本信息以及客房的定义。注意客房的“货币类型”和“非空约束”。*
```
package models

import "gorm.io/gorm"

// Hotel 酒店表
type Hotel struct {
    HotelID   uint   `gorm:"primaryKey;autoIncrement" json:"hotel_id"`
    Name      string `gorm:"size:100;not null" json:"name"`
    City      string `gorm:"size:50;not null;index" json:"city"`     // 建立索引方便查询
    District  string `gorm:"size:50;not null;index" json:"district"` // 建立索引方便查询
    Address   string `gorm:"type:text" json:"address"`
    Rooms     []Room `gorm:"foreignKey:HotelID" json:"rooms"`        // 一对多关联
}

// Room 客房表
type Room struct {
    RoomID             uint    `gorm:"primaryKey;autoIncrement" json:"room_id"`
    HotelID            uint    `json:"hotel_id"`
    RoomType           string  `gorm:"size:50;not null" json:"room_type"` // 非空约束
    Price              float64 `gorm:"type:decimal(10,2);default:0.0" json:"price"` // 货币缺省值
    Capacity           int     `gorm:"default:2" json:"capacity"`
    TotalInventory     int     `gorm:"not null" json:"total_inventory"`
    AvailableInventory int     `gorm:"not null" json:"available_inventory"`
}
```

## 10.订单模型(models/order.go)
*这个模型最关键，它需要体现“预订日期校验”和“多入住人”逻辑。*
```
package models

import (
    "time"
)

// Order 订单表
type Order struct {
    OrderID      uint      `gorm:"primaryKey;autoIncrement" json:"order_id"`
    UserID       uint      `json:"user_id"`
    HotelID      uint      `json:"hotel_id"`
    RoomType     string    `gorm:"size:50" json:"room_type"`
    TotalPrice   float64   `gorm:"type:decimal(10,2);default:0.0" json:"total_price"`
    Status       string    `gorm:"size:20;default:'booked'" json:"status"` // booked, stayed, cancelled
    CheckInDate  time.Time `gorm:"type:date;not null" json:"check_in_date"`
    CheckOutDate time.Time `gorm:"type:date;not null" json:"check_out_date"`
    CreatedAt    time.Time `json:"created_at"`
    
    // 关联：一个订单有多个入住人
    Guests       []OrderGuest `gorm:"foreignKey:OrderID" json:"guests"`
}

// OrderGuest 入住人明细表 (用于画像统计)
type OrderGuest struct {
    GuestID      uint    `gorm:"primaryKey;autoIncrement" json:"guest_id"`
    OrderID      uint    `json:"order_id"`
    Name         string  `gorm:"size:50;not null" json:"name"`
    Gender       string  `gorm:"size:1;default:'M'" json:"gender"` // 缺省值
    IDCard       string  `gorm:"size:18;not null" json:"id_card"`  // 18位身份证规则
    Age          int     `json:"age"`
    Occupation   string  `json:"occupation"`      // 职业
    IncomeLevel  string  `json:"income_level"`    // 收入状况
    Education    string  `json:"education"`       // 受教育程度
}
```

## 主程序启动(main.go)
```
package main

import (
    "hotel-system/config"
    "hotel-system/controllers"
    "github.com/gin-gonic/gin"
)

func main() {
    r := gin.Default()

    // 允许跨域请求的中间件
    r.Use(func(c *gin.Context) {
        c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }
        c.Next()
    })

    // 连接数据库
    config.ConnectDatabase()

    // 路由设置
    r.POST("/register", controllers.Register)
    r.POST("/login", controllers.Login)

    r.GET("/hotels", controllers.SearchHotels)

    // 普通用户接口
    r.POST("/orders", controllers.CreateOrder)
	r.PUT("/orders/:id/cancel", controllers.CancelOrder)

    // 管理员/统计接口
    admin := r.Group("/admin")
    {
        admin.GET("/stats/bookings", controllers.GetBookingStats)
        admin.GET("/stats/guests", controllers.GetGuestAnalysis)
    }

    r.Run(":8080") // 在 8080 端口启动
}
```

# 三、构建React前端
## 1.初始化 React 项目
在项目根目录（与 backend 平级）打开终端，执行：
```
# 创建前端项目（使用 Vite 速度更快）
npm create vite@latest frontend -- --template react

# 进入目录
cd frontend

# 安装基础依赖
npm install
npm install axios antd @ant-design/icons react-router-dom
```

## 2.目录结构配置
在 frontend/src 下建立以下结构：
* /api: 存放 axios 请求配置。
* /pages: 存放页面（登录、首页、酒店详情、订单管理）。
* /components: 存放公共组件。

## 3.配置 Axios 访问后端
在 src/api/index.js 中创建一个基础配置，指向 Go 后端：
```
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:8080', // 指向你的 Go 后端端口
});

export default api;
```

## 4.前端：注册页面 (Register.jsx)
在 frontend/src/pages/Register.jsx 中编写：
```
import React from 'react';
import { Form, Input, Button, message, Card } from 'antd';
import api from '../api';
import { useNavigate } from 'react-router-dom';

const Register = () => {
  const navigate = useNavigate();

  const onFinish = async (values) => {
    try {
      const res = await api.post('/register', values);
      message.success('注册成功！');
      navigate('/login'); // 注册成功跳转登录
    } catch (error) {
      message.error(error.response?.data?.error || '注册失败');
    }
  };

  return (
    <div style={{ display: 'flex', justifyContent: 'center', marginTop: 100 }}>
      <Card title="用户注册" style={{ width: 400 }}>
        <Form onFinish={onFinish} layout="vertical">
          <Form.Item label="用户名" name="username" rules={[{ required: true }]}>
            <Input />
          </Form.Item>
          <Form.Item label="真实姓名" name="real_name" rules={[{ required: true }]}>
            <Input />
          </Form.Item>
          <Form.Item label="密码" name="password" rules={[{ required: true }]}>
            <Input.Password />
          </Form.Item>
          <Button type="primary" htmlType="submit" block>立即注册</Button>
          <Button type="link" onClick={() => navigate('/login')} block>已有账号？去登录</Button>
        </Form>
      </Card>
    </div>
  );
};

export default Register;
```

## 5.登录页面 (Login.jsx)
登录成功后，我们需要把 user_id 存起来，方便后续下单。
```
import React from 'react';
import { Form, Input, Button, message, Card } from 'antd';
import api from '../api';
import { useNavigate } from 'react-router-dom';

const Login = () => {
  const navigate = useNavigate();

  const onFinish = async (values) => {
    try {
      const res = await api.post('/login', values);
      message.success('登录成功！');
      // 存储用户信息到本地，后续预定会用到 user_id
      localStorage.setItem('user', JSON.stringify(res.data));
      navigate('/'); // 登录成功跳转首页（酒店搜索页）
    } catch (error) {
      message.error(error.response?.data?.error || '登录失败');
    }
  };

  return (
    <div style={{ display: 'flex', justifyContent: 'center', marginTop: 100 }}>
      <Card title="酒店预订系统 - 登录" style={{ width: 400 }}>
        <Form onFinish={onFinish} layout="vertical">
          <Form.Item label="用户名" name="username" rules={[{ required: true }]}>
            <Input />
          </Form.Item>
          <Form.Item label="密码" name="password" rules={[{ required: true }]}>
            <Input.Password />
          </Form.Item>
          <Button type="primary" htmlType="submit" block>登录</Button>
          <Button type="link" onClick={() => navigate('/register')} block>没有账号？去注册</Button>
        </Form>
      </Card>
    </div>
  );
};

export default Login;
```

## 6.配置路由 (App.jsx)
```
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Login from './pages/Login';
import Register from './pages/Register';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/" element={<div>这是首页（待开发）</div>} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```